/** ************************************************************************************************
 *  \file       Hardware.c
 *  \brief      Hardware independent part of rtos TBD
 *  \date       2019-07-01
 *  \revision   $Revision: 1.0$
 *  \author     Rommel García Hernández
 *  \copyright  Guenda Tecnología de México 2015
 *
 *  Implements the hardware independent part of the rtos TBD
 */

#include <msp430.h>
#include "Hardware.h"

/** **********************************************************************************************
 *  \brief      Hardware tick counter
 *  \range      TBD
 *  \resolution 64
 *  \unit       None
 */
static unsigned long long int hardware_tick;

/** **********************************************************************************************
 *  \brief      Counter to make a leap in the tick counter
 *  \range
 *  \resolution 16
 *  \unit       None
 */
static unsigned int leap_cnt;

/**********************************************************************************************************************
 *  HardwareInitIO()
 *********************************************************************************************************************/
/*! \brief         Inits properly all the io interfaces
*********************************************************************************************************************/
void HardwareInitIO() {

}

/**********************************************************************************************************************
 *  HardwareToggleP47()
 *********************************************************************************************************************/
/*! \brief         Helper funtion used to turn on and off a led at pin 4.7
**********************************************************************************************************************/
void HardwareToggleP47() {
    P4OUT ^= BIT7;           /* Toggle P4.7 */
}

/**********************************************************************************************************************
 *  HardwareInitTimerA2()
 *********************************************************************************************************************/
/*! \brief         Configures timer A2 and starts the interupt services
**********************************************************************************************************************/
void HardwareInitTimerA2() {
    TA2CTL   = TASSEL_1 | ID_0 | MC_1; // ACLK, Divider 1, Up mode
    TA2CCR0  = 32;
    TA2CCTL0 = CCIE; // Enable timer interrupts
    __bis_SR_register(GIE);
}

/**********************************************************************************************************************
 *  HardwareGetTick()
 *********************************************************************************************************************/
/*! \brief         Return the value of the hardware tick counter
**********************************************************************************************************************/
unsigned long long int HardwareGetTick() {
    return hardware_tick;
}

/**********************************************************************************************************************
 *  Timer_A2()
 *********************************************************************************************************************/
 /*! \brief        Tick counter interruption
 *********************************************************************************************************************/
#pragma vector=TIMER2_A0_VECTOR
__interrupt void Timer_A2(void) {
    if(leap_cnt < NUM_OF_INTERRUPTS_ERROR) {
        hardware_tick++;
        leap_cnt++;
    } else {
        /* Add an extra count to catch up */
        hardware_tick += 2;
        leap_cnt = 0;
    }
}

/**********************************************************************************************************************
 *  start_output_pin()
 *********************************************************************************************************************/
/*! \brief        Configures a pin as output
**********************************************************************************************************************/
void start_output_pin(pin_t pin) {
    *(pin.pin_dir) |= pin.pin_bit; /* sets the bit as output */
    *(pin.pin_out) &= ~pin.pin_bit; /* starts to 0 */
}

/**********************************************************************************************************************
 *  rising_edge_pin()
 *********************************************************************************************************************/
/*! \brief        Generates a transition from low to high in a pin
**********************************************************************************************************************/
void rising_edge_pin(pin_t pin) {
    *(pin.pin_out) |= pin.pin_bit;
}

/**********************************************************************************************************************
 *  falling_edge_pin()
 *********************************************************************************************************************/
/*! \brief        Generates a transition from high to low in a pin
**********************************************************************************************************************/
void falling_edge_pin(pin_t pin) {
    *(pin.pin_out) &= ~pin.pin_bit;
}

/**********************************************************************************************************************
 *  low_pulse_pin()
 *********************************************************************************************************************/
/*! \brief        Generates a low pulse in pin
**********************************************************************************************************************/
void low_pulse_pin(pin_t pin) {
    *(pin.pin_out) &= ~pin.pin_bit;
    __delay_cycles(10);
    *(pin.pin_out) |= pin.pin_bit;
}
